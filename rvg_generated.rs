// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod rvg {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum PathOp {
  Move = 0,
  Line = 1,
  Quad = 2,
  Cubic = 3,
  Arc = 4,
  Solid = 16,
  Bitmap = 17,
  Tile = 18,
  Pattern = 19,
  Stroke = 20,
  Width = 21,
  Dashed = 22,
  JoinMiter = 32,
  JoinBevel = 33,
  JoinRound = 34,

}

const ENUM_MIN_PATH_OP: u8 = 0;
const ENUM_MAX_PATH_OP: u8 = 34;

impl<'a> flatbuffers::Follow<'a> for PathOp {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for PathOp {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const PathOp;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const PathOp;
    unsafe { *p }
  }
}

impl flatbuffers::Push for PathOp {
    type Output = PathOp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PathOp>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PATH_OP:[PathOp; 15] = [
  PathOp::Move,
  PathOp::Line,
  PathOp::Quad,
  PathOp::Cubic,
  PathOp::Arc,
  PathOp::Solid,
  PathOp::Bitmap,
  PathOp::Tile,
  PathOp::Pattern,
  PathOp::Stroke,
  PathOp::Width,
  PathOp::Dashed,
  PathOp::JoinMiter,
  PathOp::JoinBevel,
  PathOp::JoinRound
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PATH_OP:[&'static str; 35] = [
    "Move",
    "Line",
    "Quad",
    "Cubic",
    "Arc",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Solid",
    "Bitmap",
    "Tile",
    "Pattern",
    "Stroke",
    "Width",
    "Dashed",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "JoinMiter",
    "JoinBevel",
    "JoinRound"
];

pub fn enum_name_path_op(e: PathOp) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_PATH_OP[index]
}

// struct Color, aligned to 2
#[repr(C, align(2))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Color {
  r_: u16,
  g_: u16,
  b_: u16,
  a_: u16,
} // pub struct Color
impl flatbuffers::SafeSliceAccess for Color {}
impl<'a> flatbuffers::Follow<'a> for Color {
  type Inner = &'a Color;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Color>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Color {
  type Inner = &'a Color;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Color>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Color as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Color {
    type Output = Color;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Color as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Color {
  pub fn new<'a>(_r: u16, _g: u16, _b: u16, _a: u16) -> Self {
    Color {
      r_: _r.to_little_endian(),
      g_: _g.to_little_endian(),
      b_: _b.to_little_endian(),
      a_: _a.to_little_endian(),

    }
  }
  pub fn r<'a>(&'a self) -> u16 {
    self.r_.from_little_endian()
  }
  pub fn g<'a>(&'a self) -> u16 {
    self.g_.from_little_endian()
  }
  pub fn b<'a>(&'a self) -> u16 {
    self.b_.from_little_endian()
  }
  pub fn a<'a>(&'a self) -> u16 {
    self.a_.from_little_endian()
  }
}

// struct Operation, aligned to 2
#[repr(C, align(2))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Operation {
  path_op_: PathOp,
  padding0__: u8,
  value_: u16,
} // pub struct Operation
impl flatbuffers::SafeSliceAccess for Operation {}
impl<'a> flatbuffers::Follow<'a> for Operation {
  type Inner = &'a Operation;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Operation>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Operation {
  type Inner = &'a Operation;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Operation>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Operation {
    type Output = Operation;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Operation as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Operation {
    type Output = Operation;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Operation as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Operation {
  pub fn new<'a>(_path_op: PathOp, _value: u16) -> Self {
    Operation {
      path_op_: _path_op.to_little_endian(),
      value_: _value.to_little_endian(),

      padding0__: 0,
    }
  }
  pub fn path_op<'a>(&'a self) -> PathOp {
    self.path_op_.from_little_endian()
  }
  pub fn value<'a>(&'a self) -> u16 {
    self.value_.from_little_endian()
  }
}

pub enum BitmapOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bitmap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bitmap<'a> {
    type Inner = Bitmap<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bitmap<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bitmap {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BitmapArgs<'args>) -> flatbuffers::WIPOffset<Bitmap<'bldr>> {
      let mut builder = BitmapBuilder::new(_fbb);
      if let Some(x) = args.pixels { builder.add_pixels(x); }
      builder.add_pitch(args.pitch);
      builder.finish()
    }

    pub const VT_PITCH: flatbuffers::VOffsetT = 4;
    pub const VT_PIXELS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn pitch(&self) -> u16 {
    self._tab.get::<u16>(Bitmap::VT_PITCH, Some(0)).unwrap()
  }
  #[inline]
  pub fn pixels(&self) -> Option<&'a [Color]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Color>>>(Bitmap::VT_PIXELS, None).map(|v| v.safe_slice() )
  }
}

pub struct BitmapArgs<'a> {
    pub pitch: u16,
    pub pixels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Color>>>,
}
impl<'a> Default for BitmapArgs<'a> {
    #[inline]
    fn default() -> Self {
        BitmapArgs {
            pitch: 0,
            pixels: None,
        }
    }
}
pub struct BitmapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BitmapBuilder<'a, 'b> {
  #[inline]
  pub fn add_pitch(&mut self, pitch: u16) {
    self.fbb_.push_slot::<u16>(Bitmap::VT_PITCH, pitch, 0);
  }
  #[inline]
  pub fn add_pixels(&mut self, pixels: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Color>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bitmap::VT_PIXELS, pixels);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BitmapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BitmapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bitmap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GraphicOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Graphic<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graphic<'a> {
    type Inner = Graphic<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Graphic<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Graphic {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GraphicArgs<'args>) -> flatbuffers::WIPOffset<Graphic<'bldr>> {
      let mut builder = GraphicBuilder::new(_fbb);
      if let Some(x) = args.glyphs { builder.add_glyphs(x); }
      if let Some(x) = args.bitmaps { builder.add_bitmaps(x); }
      if let Some(x) = args.colors { builder.add_colors(x); }
      if let Some(x) = args.positions { builder.add_positions(x); }
      if let Some(x) = args.operations { builder.add_operations(x); }
      builder.add_aspect_ratio(args.aspect_ratio);
      builder.add_three_dimensions(args.three_dimensions);
      builder.add_main_axis(args.main_axis);
      builder.finish()
    }

    pub const VT_MAIN_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_THREE_DIMENSIONS: flatbuffers::VOffsetT = 6;
    pub const VT_ASPECT_RATIO: flatbuffers::VOffsetT = 8;
    pub const VT_OPERATIONS: flatbuffers::VOffsetT = 10;
    pub const VT_POSITIONS: flatbuffers::VOffsetT = 12;
    pub const VT_COLORS: flatbuffers::VOffsetT = 14;
    pub const VT_BITMAPS: flatbuffers::VOffsetT = 16;
    pub const VT_GLYPHS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn main_axis(&self) -> bool {
    self._tab.get::<bool>(Graphic::VT_MAIN_AXIS, Some(false)).unwrap()
  }
  #[inline]
  pub fn three_dimensions(&self) -> bool {
    self._tab.get::<bool>(Graphic::VT_THREE_DIMENSIONS, Some(false)).unwrap()
  }
  #[inline]
  pub fn aspect_ratio(&self) -> u16 {
    self._tab.get::<u16>(Graphic::VT_ASPECT_RATIO, Some(0)).unwrap()
  }
  #[inline]
  pub fn operations(&self) -> Option<&'a [Operation]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Operation>>>(Graphic::VT_OPERATIONS, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn positions(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Graphic::VT_POSITIONS, None)
  }
  #[inline]
  pub fn colors(&self) -> Option<&'a [Color]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Color>>>(Graphic::VT_COLORS, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn bitmaps(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bitmap<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bitmap<'a>>>>>(Graphic::VT_BITMAPS, None)
  }
  #[inline]
  pub fn glyphs(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Graphic<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Graphic<'a>>>>>(Graphic::VT_GLYPHS, None)
  }
}

pub struct GraphicArgs<'a> {
    pub main_axis: bool,
    pub three_dimensions: bool,
    pub aspect_ratio: u16,
    pub operations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Operation>>>,
    pub positions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
    pub colors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Color>>>,
    pub bitmaps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bitmap<'a >>>>>,
    pub glyphs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Graphic<'a >>>>>,
}
impl<'a> Default for GraphicArgs<'a> {
    #[inline]
    fn default() -> Self {
        GraphicArgs {
            main_axis: false,
            three_dimensions: false,
            aspect_ratio: 0,
            operations: None,
            positions: None,
            colors: None,
            bitmaps: None,
            glyphs: None,
        }
    }
}
pub struct GraphicBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GraphicBuilder<'a, 'b> {
  #[inline]
  pub fn add_main_axis(&mut self, main_axis: bool) {
    self.fbb_.push_slot::<bool>(Graphic::VT_MAIN_AXIS, main_axis, false);
  }
  #[inline]
  pub fn add_three_dimensions(&mut self, three_dimensions: bool) {
    self.fbb_.push_slot::<bool>(Graphic::VT_THREE_DIMENSIONS, three_dimensions, false);
  }
  #[inline]
  pub fn add_aspect_ratio(&mut self, aspect_ratio: u16) {
    self.fbb_.push_slot::<u16>(Graphic::VT_ASPECT_RATIO, aspect_ratio, 0);
  }
  #[inline]
  pub fn add_operations(&mut self, operations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Operation>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graphic::VT_OPERATIONS, operations);
  }
  #[inline]
  pub fn add_positions(&mut self, positions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graphic::VT_POSITIONS, positions);
  }
  #[inline]
  pub fn add_colors(&mut self, colors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Color>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graphic::VT_COLORS, colors);
  }
  #[inline]
  pub fn add_bitmaps(&mut self, bitmaps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bitmap<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graphic::VT_BITMAPS, bitmaps);
  }
  #[inline]
  pub fn add_glyphs(&mut self, glyphs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Graphic<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graphic::VT_GLYPHS, glyphs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GraphicBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GraphicBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Graphic<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_graphic<'a>(buf: &'a [u8]) -> Graphic<'a> {
  flatbuffers::get_root::<Graphic<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_graphic<'a>(buf: &'a [u8]) -> Graphic<'a> {
  flatbuffers::get_size_prefixed_root::<Graphic<'a>>(buf)
}

#[inline]
pub fn finish_graphic_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Graphic<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_graphic_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Graphic<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Rvg

